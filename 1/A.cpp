/*
 * Нетрудно заметить, что...
 *
 * Предположим, что на определенном отрезке грядки, начиная с начала, нам известны данные для самой большой фотографии на данном участке.
 * Что может произойти при добавлении еще одного цветка справа? Может случиться так, что этот цветок войдет в фотографию, которая окажется больше, чем была ранее.
 * Что нам нужно, чтобы это проверить? Нужно знать максимально возможную левую границу для фотографии.
 * И тогда при добавлении нового цветка, мы сможем посчитать максимально возможную фотографию, правым концом которой является только что добавленный цветок.
 * Таким образом, постепенно добавляя все цветы с грядки, мы найдем максимально возможную большую фотографию для данной грядки.
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>

using namespace std;

int main() {
    size_t n;
    cin >> n;

    if (n < 3) {
        cout << 1 << " " << n;
        return 0;
    }

    size_t max_len = 2, len = 2, max_len_l = 1;

    size_t left = 1;
    int64_t prev_prev, prev, cur;

    cin >> prev_prev >> prev;

    for (size_t i = 3; i <= n; ++i) {
        cin >> cur;
        if (cur == prev && prev == prev_prev) {
            left = i - 1;
            len = 1;
        }
        len++;
        if (len > max_len) {
            max_len = len;
            max_len_l = left;
        }
        prev_prev = prev;
        prev = cur;
    }

    cout << max_len_l << " " << max_len_l + max_len - 1;

    return 0;
}