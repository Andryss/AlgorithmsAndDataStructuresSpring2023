/*
 * Нетрудно заметить, что...
 *
 * Давайте рассмотрим какую-то случайно проведенную медиану из вершины X в вершину Y. Пусть по одну сторону n вершин, а по другую n + r (где r >= 0).
 * Тогда из того, что общее количество вершин четно, то (n + n + r) - четно. Значит r - четно.
 * Значит при любом случайном разделении количество вершин по обе стороны различается на какое-то четное число.
 * Теперь давайте зафиксируем вершину X и отвяжемся от вершины Y.
 * Будем очень маленькими шажками поворачивать медиану в сторону стороны с (n + r) вершинами (вращаем медиану вокруг вершины X).
 * Поскольку, никакие три вершины не лежат на одной прямой, то через некоторое время наша медиана пересечется некоторой вершиной Z (первое возможное пересечение).
 * Эта вершина при проведении медианы от X к Y находилась на стороне с (n + r) вершинами.
 * Заметим, что если теперь провести медиану через вершины X и Z. То теперь по одну сторону стало n + 1 вершина (добавилась Y), а по другую n + r - 1 (ушла Z).
 * Таким образом, повторяя вышеперечисленную операцию достаточное количество раз мы приравниваем вершины по обе стороны от медианы.
 * Это конечно круто, но как решать то?
 * Давайте заметим, что полученный вывод был получен из учета совершенно случайно взятой вершины X.
 * И что это значит?
 * А давайте как вершину X выберем самую первую из всех, а потом для выбора подходящей второй вершины просто пробежимся по всем оставшимся и посчитаем.
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

using namespace std;

struct point {
    int32_t x;
    int32_t y;
};

int main() {
    int32_t n;
    cin >> n;

    vector<point> points(n);
    int32_t curX, curY;
    int32_t maxX = -1000000, minY = 1000000, start_idx;
    for (int32_t i = 0; i < n; ++i) {
        cin >> curX >> curY;
        points[i] = {curX, curY};
        if (curX > maxX || curX == maxX && curY < minY) {
            maxX = curX;
            minY = curY;
            start_idx = i;
        }
    }

    vector<pair<double,int32_t>> values;
    int32_t dX, dY;
    for (int32_t i = 0; i < n; ++i) {
        if (i != start_idx) {
            dX = points[i].x - maxX, dY = points[i].y - minY;
            if (dX == 0) {
                if (dY > 0) {
                    values.emplace_back(-10000000, i);
                } else {
                    values.emplace_back(10000000, i);
                }
            } else {
                double metric = (double) dY / dX;
                values.emplace_back(metric, i);
            }
        }
    }
    sort(values.begin(), values.end());

    cout << (start_idx + 1) << ' ' << (values[values.size() >> 1].second + 1);

    return 0;
}
