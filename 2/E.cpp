/*
 * Нетрудно заметить, что...
 *
 * Предположим, что мы написали функцию, которая может ответить на вопрос:
 * "Сможем ли мы разместить столько-то коров в такие-то стойла с таким-то минимальным расстоянием между ними?".
 * Коровы и стойла зафиксированы и даны по условию задачи, значит нас будут интересовать только различные минимальные расстояния между ними.
 * Предположим также, что мы можем выполнить соответствующее размещение для минимального расстояния CAN.
 * Заметим, что и для всех L < CAN мы можем выполнить соответствующее размещение (просто повторив размещение для CAN).
 * Предположим, что мы НЕ можем выполнить соответствующее размещение при минимальном расстоянии CAN'T.
 * Значит и для всех L > CAN'T мы тоже НЕ сможем этого сделать.
 * Получается, что среди всевозможных расстояний от 1 до max(стойла) нам нужно найти то самое максимально возможное CAN (или минимальное CAN'T).
 * Звучит, как задача бинарного поиска, не так ли?
 * Осталось только понять, как нам определить функцию, отвечающую выше поставленному вопросу.
 * Задумка проста, давайте отсортируем стойла по возрастанию координат. Разместим первую корову в первое стойло.
 * А дальше будем решать задачу динамического программирования: для каждого нового стойла отвечаем на вопрос: можем ли мы посадить сюда следующую корову так,
 * чтобы расстояние до предыдущей было не меньше такого-то минимального. Если да, то сажаем и запоминаем это стойло как последнее, иначе идем дальше.
 * И в итоге мы сможем проверить, всех ли коров мы разметили при данном минимальном расстоянии.
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>

using namespace std;

bool can_place(vector<int32_t> coords, size_t min_len, int16_t cows) {
    cows--;
    int32_t prev_coord = coords.at(0);
    for (size_t i = 1; i < coords.size(); ++i) {
        if (coords.at(i) - prev_coord < min_len) continue;
        prev_coord = coords.at(i);
        if (--cows == 0) return true;
    }
    return false;
}

int main() {
    int16_t n, k;
    cin >> n >> k;
    vector<int32_t> coords;
    int32_t cur_coord;
    for (int16_t i = 0; i < n; ++i) {
        cin >> cur_coord;
        coords.push_back(cur_coord);
    }
    size_t l = 0, r = coords.at(coords.size() - 1);
    while (l < r - 1) {
        size_t m = (l + r) >> 1;
        if (can_place(coords, m, k)) l = m;
        else r = m;
    }
    cout << l;

    return 0;
}
