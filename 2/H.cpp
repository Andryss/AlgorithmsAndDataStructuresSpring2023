/*
 * Нетрудно заметить, что...
 *
 * Заметим, что при разбиении товаров на несколько чеков (k-1) самых дорогих товаров мы никогда не сможем получить бесплатно.
 * Для того, чтобы получить товар бесплатно необходимо, чтобы было как минимум (k-1) товаров большей стоимости.
 * Тогда совершенно очевидно, что для максимального уменьшения итоговой стоимости товаров необходимо на один чек пробить k самых дорогих товаров.
 * Теперь у нас осталось k-n товаров, которых мы хотим снова разбить на несколько чеков.
 * Повторяем итерацию, пока у нас не останется меньше k товаров для последнего чека.
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    int32_t n; int16_t k;
    cin >> n >> k;
    vector<int16_t> costs; int16_t cur_cost; int32_t sum = 0;
    for (int32_t i = 0; i < n; i++) {
        cin >> cur_cost;
        costs.push_back(cur_cost);
        sum += cur_cost;
    }
    stable_sort(costs.rbegin(), costs.rend());
    int32_t kth = 0;
    for (int16_t cost : costs) {
        if (++kth == k) {
            sum -= cost;
            kth = 0;
        }
    }
    cout << sum;
    return 0;
}
