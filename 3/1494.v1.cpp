/*
 * Нетрудно заметить, что...
 *
 * Давайте подумаем как понять, что пользователь читер.
 * Первый шар мы всегда можем взять произвольный (из произвольного места). Что же касается остальных.
 * Если для текущего взятого шара мы до этого достали все шары с бОльшим номером до максимального взятого ранее, то все хорошо, иначе считается, что читер.
 *
 * Хорошо, но как же нам для каждого шара проверить, все ли шары с бОльшим номером были взяты до него.
 * Я предлагаю следующую идею. Заранее создать и заполнить set<?> шарами со всеми номерами.
 * И каждый взятый шар удалять из множества.
 *
 * Но как же проверить, взяты ли все шары с бОльшим номером? Использовать магический upper_bound.
 * И если этот элемент окажется меньше, чем максимальный встреченный ранее, значит мы достали не все шары с бОльшим номером.
 *
 * Оценка сложности: O(NlogN)
 * Оценка памяти: O(NlogN)
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <set>

using namespace std;

int main() {
    int32_t n;
    cin >> n;

    int32_t cur, max;

    set<int32_t> pulled;
    for (int32_t i = 1; i <= n + 1; ++i) pulled.insert(i);

    cin >> cur;
    pulled.erase(cur);
    max = cur;
    n--;

    while (n --> 0) {
        cin >> cur;
        if (cur < max && *(pulled.upper_bound(cur)) < max) {
            cout << "Cheater";
            return 0;
        }
        pulled.erase(cur);
        max = std::max(max, cur);
    }

    cout << "Not a proof";
    return 0;
}
