/*
 * Нетрудно заметить, что...
 *
 * Давайте для начала поймем, что мы можем определить индексы всех выбывающих людей (считая от начала круга).
 * То есть если у нас есть данные n=4 и k=3 (4 человека, счет через 3), то мы можем определить, что выбудут люди в порядке 3, 2, 2, 1
 * (то есть сначала выйдет человек с индексом 3 и номером 3, потом с индексом 2 и номером 2, потом с индексом 2 и номером 4, и оставшийся с индексом 1 и номером 1).
 * Отслеживать это не сложно, мы можем двигать указатель на текущего выбывающего учитывая постоянно уменьшающийся круг.
 *
 * Но что это нам дает? Дает это нам то, что теперь нам надо попробовать найти структуру, которая сможет легко удалять k-ый элемент с начала.
 * А такая структура... Есть у нас...
 *
 * Давайте создадим бинарное дерево по следующим правилам:
 * - листья будут хранить числа (номера людей в круге), причем все листья при обходе в глубину "слева направо" листья образуют последовательность, как по кругу
 * - остальные вершины будут хранить число - количество листьев в своих поддеревьях
 *
 * Из предыдущих правил следует, что после начального построения корень этого дерева будет хранить число N, его дети N/2 и так далее.
 * Но что это нам дает? Предположим, что мы хотим удалить k-ый элемент с начала. Что мы будем делать?
 * Из корня смотрим на левого ребенка, его значение. Если оно больше k, значит k-ый элемент находится там,
 * иначе стоит искать его в правом ребеке (правда искать там мы будем уже не k-ый элемент, а k за вычетом количества листьев левого ребенка).
 * Итерируемся рекурсивно на интересующем нас ребенке. Когда же мы дойдем до листа, то его значение это и есть интересующий нас k-ый элемент с начала.
 * После этого этот лист можно удалить, а из всех вершин, через которые мы прошли, вычесть 1, так как одного листа уже нет.
 *
 * Итого получаем, что пользуясь этой структурой мы можем за logN удалять k-ый элемент с начала. Думаю это успех!
 * Осталось только правильно сформировать такое дерево и дело в шляпе.
 *
 * Оценка сложности: O(NlogN)
 * Оценка памяти: O(N)
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>

using namespace std;

class cycle_training {
private:
    struct node {
        node* left;
        node* right;
        int32_t number;
        int32_t value;
    };

    node* head = nullptr;

    node* create_tree(int32_t lo, int32_t hi) { // NOLINT(misc-no-recursion)
        if (lo == hi) {
            return new node{.left = nullptr, .right = nullptr, .number = lo, .value = 1};
        }
        int32_t m = (lo + hi) >> 1;
        node* left = create_tree(lo, m);
        node* right = create_tree(m + 1, hi);
        return new node{.left = left, .right = right, .number = 0, .value = left->value + right->value};
    }

    int32_t remove_element(node* node, int32_t value) { // NOLINT(misc-no-recursion)
        node->value--;
        if (node->number != 0) return node->number;
        if (value > node->left->value) {
            return remove_element(node->right, value - node->left->value);
        } else {
            return remove_element(node->left, value);
        }
    }

public:
    explicit cycle_training(int32_t init_size) {
        head = create_tree(1, init_size);
    }

    int32_t remove_by_index_and_get(int32_t index) {
        return remove_element(head, index);
    }

};


int main() {
    int32_t n, k;
    cin >> n >> k;

    cycle_training cycle(n);

    int32_t next = k - 1;
    while (n > 1) {
        cout << cycle.remove_by_index_and_get(next + 1) << ' ';
        next = (next + k - 1) % (n - 1);
        n--;
    }
    cout << cycle.remove_by_index_and_get(1) << ' ';

    return 0;
}
