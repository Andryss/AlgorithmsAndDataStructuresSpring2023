/*
 * Нетрудно заметить, что... (условие задачи это просто что-то с чем-то)
 *
 * Суть задачи: найти максимальный путь (по весу) в ориентированном ациклическом графе из одной вершины в другую.
 *
 * Попытка 1: алгоритм Флойда-Уоршелла
 *
 * Интуиция: переберем все тройки вершин A, B, C и если путь A->C будет меньше, чем A->B->C, то обновим расстояние до C.
 *
 * На самом деле:
 * Пусть мы имеем функцию, которая находит расстояние от вершины A до B используя только вершины из множества 1,2,3,...,K.
 * Очевидно, нас интересует значение функции при K=N. Как нам его вычислить?
 * Для какого-то K путь из A в B может либо не проходить через вершину K (то есть будет равен максимальному пути из A в B при использовании только вершин 1,...,K-1),
 * либо будет проходить через нее (то есть будет состоять из максимального пути из A в K и пути из K в B с использованием только вершин 1,...,K-1).
 * То есть в виде функции: max_path(A,B,K) = max(max_path(A,B,K-1), max_path(A,K,K-1) + max_path(K,B,K-1)).
 * Значит нам нужно найти все расстояние между парами вершин для K-1 и мы сможем найти все расстояния между всеми вершинами для K.
 * Также рассмотрим K=0 (множество дополнительных вершин пустое). Для такого K расстояние между любыми вершинами A и B равно либо весу ребра,
 * если существует ребро A-B, либо -infinity, если такого ребра нет.
 *
 * Оценка сложности: O(N^3)
 * Оценка памяти: O(N^2)
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>

using namespace std;

/*
 * Floyd Warshall Algorithm
 * time complexity: O(n^3)
 * time: 0.484
 * space complexity: O(n^2)
 * space: 1 428 КБ
 */

int main() {
    int16_t n; int32_t m;
    cin >> n >> m;

    vector<vector<int32_t>> distance(n, vector<int32_t>(n));
    int16_t from, to, weight;
    while (m --> 0) {
        cin >> from >> to >> weight;
        distance[from - 1][to - 1] = weight;
    }


    for (int16_t i = 0; i < n; ++i) {
        for (int16_t u = 0; u < n; ++u) {
            if (distance[u][i] > 0) {
                for (int16_t v = 0; v < n; ++v) {
                    if (distance[i][v] > 0 && u != v)
                        distance[u][v] = max(distance[u][v], distance[u][i] + distance[i][v]);
                }
            }
        }
    }

    int16_t start, finish;
    cin >> start >> finish;
    int32_t dist = distance[start - 1][finish - 1];
    if (dist > 0) {
        cout << dist;
    } else {
        cout << "No solution";
    }

    return 0;
}
