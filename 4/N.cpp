/*
 * Нетрудно заметить, что...
 *
 * Я утверждаю следующее:
 *
 * 1) Хотя бы один цикл есть всегда.
 * Что значит "цикл"? Это такая ситуация, при которой ключ от свинки p_1 лежит в p_2, ключ от p_2 лежит в p_3, ..., ключ от p_n лежит в p_1.
 * Действительно, расположим всех свинок так, чтобы ключ от первой лежал во второй, от второй в третьей и т.д.
 * В какой-то момент у нас образуется цикл (то есть ключ от свинки i будет лежать в одной из предыдущих) либо мы дойдем до последней свинки и окажется,
 * что ключ от нее может лежать только в одной из предыдущих и никак иначе.
 *
 * 2) Если у нас есть цикл, то мы будем вынуждены разбить в нем хотя бы одну свинку.
 * Действительно, поскольку ключ от каждой свинки только один, то ключи от всех свинок в цикле лежат в других свинках этого же цикла.
 * Значит никаким образом мы не сможем "открыть" весь цикл иначе, как разбив в нем хотя бы одну свинку.
 *
 * 3) Предположим ситуацию, когда все циклы "открыты". Тогда все остальные свинки мы тоже сможем открыть.
 * Действительно, рассмотрим одну из "закрытых" свинок. Теперь перейдем от нее к свинке, держащей ключ на нее. Далее перейдем по аналогии к следующей свинке.
 * Поскольку все циклы "открыты", то вернуться к уже пройденной мы не можем. Значит когда-нибудь мы дойдем до открытой свинки.
 *
 * На основе моих утверждений можно сказать, что минимально возможное количество разбитых свинок будет равно количеству циклов.
 *
 * Что будем делать для поиска циклов?
 * Будем помечать каждую свинку числом 0 - если о ней ничего не известно, 1 - если мы посетили ее за обход, 2 - если она уже открыта.
 * Тогда начнем обходить всех свинок начиная с первой. Присвоим ей номер 1 и посмотрим на "необходимую" свинку для открытия этой.
 * Если у "необходимой" свинки номер 2, то просто откроем текущую и закончим обход (цикл не найден).
 * Если у "необходимой" свинки номер 1, то мы нашли цикл (дошли до уже посещенной вершины за обход), тогда откроем все посещенные вершины и разобьем одну свинку.
 * Если же про необходимую свинку ничего не известно, то рекурсивно запустимся от нее.
 * Так мы и найдем все циклы.
 *
 * Оценка сложности: O(N)
 * Оценка памяти: O(N)
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>

using namespace std;

bool find_cycle(int16_t i, vector<int16_t> &connections, vector<bool> &opened, vector<bool> &visited) {
    visited[i] = true;
    int16_t need = connections[i];
    if (opened[need]) {
        opened[i] = true;
        return false;
    }
    if (visited[need]) {
        opened[i] = true;
        return true;
    }
    bool cycled = find_cycle(need, connections, opened, visited);
    opened[i] = true;
    return cycled;
}

int main() {

    int16_t n;
    cin >> n;

    vector<int16_t> connections(n+1);
    vector<bool> opened(n+1);

    for (int16_t i = 1; i <= n; ++i) {
        cin >> connections[i];
    }

    int16_t broken = 0;

    for (int16_t i = 1; i <= n; ++i) {
        if (!opened[i]) {
            vector<bool> visited(n+1);
            if (find_cycle(i, connections, opened, visited)) broken++;
        }
    }

    cout << broken;

    return 0;
}
