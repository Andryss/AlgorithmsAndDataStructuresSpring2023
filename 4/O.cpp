/*
 * Нетрудно заметить, что...
 *
 * Кажется, нам нужно решить задачу раскраски графов в два цвета.
 *
 * Заметим, что лкшат можно разделить на некие обособленные группы так, чтобы никакая пара лкшат из любых обособленных групп не обменивалась записками.
 * (аналогия компонент связности для графа, то есть обособленных групп будет одна или может быть больше)
 *
 * Поступим следующим образом: каждому лкшонку будем присваивать одну из трех меток.
 * 0 - если он пока не имеет группы, 1 - если он подразделен в первую группу (какою именно - не важно), 2 - если во второю группу.
 * После чего посмотрим на первого, не имеющего группы лкшонка, присвоим ему группу 1 и запустим на нем следующий алгоритм.
 *
 * Посмотрим на всех, с кем он обменивался. Если вдруг окажется, что он обменивался с кем-то из своей группы, то мы не можем разделить всех на две группы.
 * А если вдруг он обменивался с кем-то без группы, то присвоим тем противоположную группу и рекурсивно запустим алгоритм на них.
 *
 * Хочется заметить, что выбор группы (1 или 2) для первого лкшонка не принципиален, так как в любом случае все его "соседи" не будут иметь группы.
 *
 * Таким образом при каждом запуске алгоритма получится, что если он отработал успешно, то без группы останутся только те лкшата,
 * которые не обменивались ни с кем из уже определенных в группы лкшат. То есть за один обход мы раскрасим всех лкшат из некой обособленные группы.
 *
 * Значит мы можем запускать алгоритм на любом оставшемся лкшенке без группы до тех пор, пока либо не распределим всех на две группы (лкшата без группы кончатся),
 * либо алгоритм скажет, что такое разделение невозможно на некой обособленной группе.
 *
 * Оценка сложности: O(N+M)
 * Оценка памяти: O(N+M)
 *
 * Реализация идеи предлагается читателю в качестве несложного упражнения...
 */

#include <iostream>
#include <vector>

using namespace std;

bool can_divide(int16_t i, vector<int16_t> &groups, vector<vector<int16_t>> &connections) {
    int16_t i_group = groups[i];
    for (int16_t mate : connections[i]) {
        if (i_group == groups[mate]) return false;
        if (groups[mate] == 0) {
            groups[mate] = static_cast<int16_t>(i_group ^ 3);
            if (!can_divide(mate, groups, connections)) return false;
        }
    }
    return true;
}

int main() {
    int16_t n, m;
    cin >> n >> m;

    vector<vector<int16_t>> connections(n+1);

    int16_t first, second;
    for (int16_t i = 0; i < m; ++i) {
        cin >> first >> second;
        connections[first].push_back(second);
        connections[second].push_back(first);
    }

    vector<int16_t> groups(n+1);

    for (int16_t i = 1; i <= n; ++i) {
        if (groups[i] == 0) {
            groups[i] = 1;
            if (!can_divide(i, groups, connections)) {
                cout << "NO";
                return 0;
            }
        }
    }

    cout << "YES";

    return 0;
}
